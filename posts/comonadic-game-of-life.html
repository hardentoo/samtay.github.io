<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Who needs HashLife when you have Comonads?</title>
    <link href="../css/main.css" rel="stylesheet" type="text/css" />
    <link href="https://fonts.googleapis.com/css?family=Fira+Mono" rel="stylesheet">
  </head>

  <body>
      <h1>Who needs HashLife when you have Comonads?</h1>

<div id="content">
<div id="toc"><ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#what-is-the-game-of-life">What is the Game of Life?</a></li>
<li><a href="#a-naive-implementation">A naive implementation</a></li>
</ul></li>
<li><a href="#comonads">Comonads</a><ul>
<li><a href="#definition">Definition</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#applying-to-the-game-of-life">Applying to the Game of Life</a></li>
</ul></li>
<li><a href="#performance">Performance</a><ul>
<li><a href="#initial">Initial</a></li>
<li><a href="#comonads-to-the-rescue">Comonads to the rescue</a></li>
</ul></li>
<li><a href="#further-reading">Further reading</a></li>
</ul></div>
<h2 id="introduction">Introduction</h2>
<p>I’m going to talk a little bit about Conway’s Game of Life, Comonads in practical use, and the performance improvement that they have to offer. If you already know what the GoL is, skip the introduction, and if you’re already familiar with comonads and how they are defined in Haskell, feel free to skip down to the performance section.</p>
<h3 id="what-is-the-game-of-life">What is the Game of Life?</h3>
<p>Conway’s <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a> is a cellular automaton of simple cells, each following simple rules, from which very complex behavior emerges under the right conditions. It is one of many examples of <a href="https://en.wikipedia.org/wiki/Complex_systems">complex systems</a>.</p>
<p>In a nutshell, there is a 2D grid of cells, each of which has two possible states: alive or dead. The grid evolves in discrete steps of time <code>t</code>. At time <code>t = 0</code>, we give the board some initial state. We can pick certain cells to be alive or dead, or let a computer randomly decide what the grid should look like. For all <code>t &gt; 0</code>, the grid evolves to step <code>t + 1</code> based on these simple rules:</p>
<ul>
<li>Any live cell with exactly two or three live neighbours stays alive.</li>
<li>Any dead cell with exactly three live neighbours becomes alive.</li>
<li>All other cells die.</li>
</ul>
<h3 id="a-naive-implementation">A naive implementation</h3>
<p>Yesterday I finished a little <a href="https://github.com/samtay/conway/tree/v0.0.0">terminal application</a> to play around with the GoL (link set to “initial” version before comonads). As you can guess from the rules above, the GoL is very easy to program; the difficulty is in programming it <em>efficiently</em>. One well known method of computing the game is known as HashLife, which is a pretty objectively complex technique. (Someone did this, or some of it, in Haskell <a href="http://dotat.at/prog/life/hslife.hs">here</a>.)</p>
<p>In my first pass at this, instead of creating a custom data structure directly I opted to leverage <a href="http://hackage.haskell.org/package/grid">grid</a> which is a really cool library that is useful for exploring mathematical grids/graphs/lattices:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Math.Geometry.Grid</span> (<span class="dt">Index</span>)
<span class="kw">import </span><span class="dt">Math.Geometry.Grid.Octagonal</span> (<span class="dt">TorOctGrid</span>)
<span class="kw">import </span><span class="dt">Math.Geometry.GridMap.Lazy</span> (<span class="dt">LGridMap</span>)

<span class="kw">data</span> <span class="dt">St</span> <span class="fu">=</span> <span class="dt">Alive</span> <span class="fu">|</span> <span class="dt">Dead</span>
<span class="kw">type</span> <span class="dt">Board</span> <span class="fu">=</span> <span class="dt">LGridMap</span> <span class="dt">TorOctGrid</span> <span class="dt">St</span>
<span class="kw">type</span> <span class="dt">Cell</span> <span class="fu">=</span> <span class="dt">Index</span> <span class="dt">Board</span></code></pre></div>
<p>It was nice to do this first because I got <strong>a lot</strong> for free. Essentially my board looks like a mapping of <code>(x,y)</code> coordinates to cell states. In fact, the <code>toList</code> function that we get from the <code>Grid</code> typeclass confirms this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> toList <span class="fu">$</span> blinker <span class="dv">3</span> <span class="dv">3</span>
[((<span class="dv">0</span>,<span class="dv">0</span>),<span class="dt">Dead</span>),((<span class="dv">0</span>,<span class="dv">1</span>),<span class="dt">Alive</span>),((<span class="dv">0</span>,<span class="dv">2</span>),<span class="dt">Dead</span>),((<span class="dv">1</span>,<span class="dv">0</span>),<span class="dt">Dead</span>),((<span class="dv">1</span>,<span class="dv">1</span>),<span class="dt">Alive</span>),((<span class="dv">1</span>,<span class="dv">2</span>),<span class="dt">Dead</span>),((<span class="dv">2</span>,<span class="dv">0</span>),<span class="dt">Dead</span>),((<span class="dv">2</span>,<span class="dv">1</span>),<span class="dt">Alive</span>),((<span class="dv">2</span>,<span class="dv">2</span>),<span class="dt">Dead</span>)]</code></pre></div>
<p>I even get a <code>neighbours</code> function that returns all 8 neighbours of a cell along with many more useful functions, so implementing game evolution was very straightforward:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">step ::</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Board</span>
step b <span class="fu">=</span> GM.mapWithKey rule b
  <span class="kw">where</span><span class="ot"> rule ::</span> <span class="dt">Cell</span> <span class="ot">-&gt;</span> <span class="dt">St</span> <span class="ot">-&gt;</span> <span class="dt">St</span>
        rule c <span class="dt">Dead</span>
          <span class="fu">|</span> liveNeighbors c <span class="fu">==</span> <span class="dv">3</span> <span class="fu">=</span> <span class="dt">Alive</span>
          <span class="fu">|</span> otherwise            <span class="fu">=</span> <span class="dt">Dead</span>
        rule c <span class="dt">Alive</span>
          <span class="fu">|</span> liveNeighbors c <span class="fu">==</span> <span class="dv">2</span> <span class="fu">=</span> <span class="dt">Alive</span>
          <span class="fu">|</span> liveNeighbors c <span class="fu">==</span> <span class="dv">3</span> <span class="fu">=</span> <span class="dt">Alive</span>
          <span class="fu">|</span> otherwise            <span class="fu">=</span> <span class="dt">Dead</span>

<span class="ot">        liveNeighbors ::</span> <span class="dt">Cell</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
        liveNeighbors c <span class="fu">=</span> population <span class="fu">$</span>
          GM.filterWithKey (const <span class="fu">.</span> (<span class="ot">`elem`</span> neighbours b c)) <span class="fu">$</span> b

<span class="ot">population ::</span> <span class="dt">Board</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
population <span class="fu">=</span> sum <span class="fu">.</span> map fn <span class="fu">.</span> GM.elems
  <span class="kw">where</span> fn <span class="dt">Alive</span> <span class="fu">=</span> <span class="dv">1</span>
        fn <span class="dt">Dead</span>  <span class="fu">=</span> <span class="dv">0</span></code></pre></div>
<p>Furthermore, using the toroidal style of grid allows modular boundaries which is how I wanted to implement this version.</p>
<p>So, you can see I was able to speed through the actual GoL logic since most of the tedious legwork was done in the grid package. My real challenge and where I spent the most effort was in the frontend, rendering and handling user interaction from a terminal. I chose to use <a href="http://hackage.haskell.org/package/brick">brick</a> which is a <em>fantastic</em> package that provides a high level declarative API to develop terminal interface applications along with a number of useful widgets - not to mention 17 awesome demo programs, great documentation, and a responsive google group. If you’re curious, <a href="https://github.com/samtay/conway/blob/v0.0.0/app/Main.hs">this</a> is how I rendered the above implementation using the brick library. But, this post is not about brick. Maybe that will come in the future.</p>
<h2 id="comonads">Comonads</h2>
<p>Like any good Haskeller I’d like to leverage whatever abstractions I can to improve the elegance and performance of this codebase. As it turns out, cellular automata are well represented by comonads.</p>
<h3 id="definition">Definition</h3>
<p>Let’s consider what the <em>dual</em> of the <code>Monad</code> type looks like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Monad definition (adapted)</span>
<span class="kw">class</span> <span class="dt">Functor</span> <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">  join   ::</span> m (m a) <span class="ot">-&gt;</span> m a
<span class="ot">  bind   ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (m a <span class="ot">-&gt;</span> m b)

<span class="co">-- Comonad definition</span>
<span class="co">-- Minimum defintion: extract, (duplicate | extend)</span>
<span class="kw">class</span> <span class="dt">Functor</span> <span class="ot">=&gt;</span> <span class="dt">Comonad</span> m <span class="kw">where</span>
<span class="ot">  extract   ::</span> m a <span class="ot">-&gt;</span> a       <span class="co">-- aka co-return</span>
<span class="ot">  duplicate ::</span> m a <span class="ot">-&gt;</span> m (m a) <span class="co">-- aka co-join</span>
<span class="ot">  extend    ::</span> (m b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (m b <span class="ot">-&gt;</span> m a) <span class="co">-- aka co-bind</span></code></pre></div>
<p>As anyone else on the internet would say, the <em>dual</em> of something is when its “arrows are flipped around”, which at first sounds like handwavey nonsense. Head <a href="http://blog.ezyang.com/2012/10/duality-for-haskellers/">here</a> for an excellent explanation of duality and how it applies to types in Haskell. I don’t want to get lost in the forest or duplicate content on the internet, so click that link or be satisfied with the fact that the arrows are literally flipped in the type signatures above.</p>
<p>I don’t want to get bogged down in category theory land - if you want to go down that path, see my <a href="#further-reading">resources</a>. Instead, let’s just build up intuition with some examples.</p>
<h3 id="examples">Examples</h3>
<p>The intuition we are trying to garner is that while monads <em>produce</em> effectful computations, comonads are <em>consumed</em> in context-sensitive computations. They usually come in handy when there is some large data structure that is composed of small, similar computations. Sound familiar?</p>
<h4 id="stream">Stream</h4>
<p>This is probably the simplest example, almost canonical to comonads:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Stream</span> a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">Stream</span> a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Stream</span> <span class="kw">where</span>
  fmap f (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="dt">Cons</span> (f x) (fmap f xs)

<span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">Stream</span> <span class="kw">where</span>
<span class="ot">  extract ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> a
  extract (<span class="dt">Cons</span> x _) <span class="fu">=</span> x

<span class="ot">  duplicate ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> (<span class="dt">Stream</span> a)
  duplicate xxs<span class="fu">@</span>(<span class="dt">Cons</span> _ xs) <span class="fu">=</span> <span class="dt">Cons</span> xxs (duplicate xs)

<span class="ot">  extend ::</span> (<span class="dt">Stream</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> b
  extend f xxs<span class="fu">@</span>(<span class="dt">Cons</span> _ xs) <span class="fu">=</span> <span class="dt">Cons</span> (f xxs) (extend f xs)</code></pre></div>
<p>So <code>extract</code> is like <code>head</code> and <code>duplicate</code> is like <code>tails</code>. <code>extend</code> on the other hand looks a little <code>fmap</code>-y:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fmap<span class="ot">   ::</span> (       a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> b
<span class="ot">extend ::</span> (<span class="dt">Stream</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> b</code></pre></div>
<p>Well, it’s sort of similar to <code>fmap</code> but the type signature is slightly different in that the function argument <code>f :: Stream a -&gt; b</code> accepts its first argument already of type <code>Stream a</code>. Consequently, <code>f</code> can <em>know</em> or be <em>context-aware</em> of the comonadic structure when it produces its return value of type <code>b</code>. This is where the power of comonad really shines. In this case, the context that <code>f</code> is aware of at <em>each</em> function call when mapping over the stream is a current element <code>x</code> (we’ll say at the current “cursor”) along with the whole tail of the list from <code>x</code> onwards.</p>
<p>This observation lends itself to the intuition we set out to build, namely that monads <em>produce</em> additional context while comonads are <em>consumed</em> within a context.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bind   ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b
<span class="ot">extend ::</span> (m a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</code></pre></div>
<p>Note that <code>bind</code> accepts a function <code>g :: a -&gt; m b</code> that takes an <code>a</code> value and <em>produces</em> a contextual value <code>m b</code>. Contrast this with <code>extend</code> accepting a function <code>f :: m a -&gt; b</code> which has <code>f</code> <em>consuming</em> the contextual value <code>m a</code>.</p>
<h4 id="zipper">Zipper</h4>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- (elems to the left) (cursor) (elems to the right)</span>
<span class="kw">data</span> <span class="dt">Zipper</span> a <span class="fu">=</span> <span class="dt">Zipper</span> [a] a [a]

<span class="co">-- moving the cursor (not changing any values, per se)</span>
left,<span class="ot"> right ::</span> <span class="dt">Zipper</span> a <span class="ot">-&gt;</span> <span class="dt">Zipper</span> a
left  (<span class="dt">Zipper</span> (l<span class="fu">:</span>ls) x rs) <span class="fu">=</span> <span class="dt">Zipper</span> ls l (x<span class="fu">:</span>rs)
right (<span class="dt">Zipper</span> ls x (r<span class="fu">:</span>rs)) <span class="fu">=</span> <span class="dt">Zipper</span> (x<span class="fu">:</span>ls) r rs

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Zipper</span> <span class="kw">where</span>
  fmap f (<span class="dt">Zipper</span> l x r) <span class="fu">=</span> <span class="dt">Zipper</span> (fmap f l) (f x) (fmap f r)

<span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">Zipper</span> <span class="kw">where</span>
  extract (<span class="dt">Zipper</span> _ x _) <span class="fu">=</span> x
  duplicate z <span class="fu">=</span> <span class="dt">Zipper</span> (iterate' left z) z (iterate' right z)
    <span class="kw">where</span> iterate' f <span class="fu">=</span> drop <span class="dv">1</span> <span class="fu">.</span> iterate f</code></pre></div>
<p>Here’s what this looks like in practice:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> z <span class="fu">=</span> <span class="dt">Zipper</span> [(<span class="fu">-</span><span class="dv">1</span>),(<span class="fu">-</span><span class="dv">2</span>)<span class="fu">..</span>] <span class="dv">0</span> [<span class="dv">1</span><span class="fu">..</span>]
λ<span class="fu">&gt;</span> <span class="kw">let</span> take' n (<span class="dt">Zipper</span> l x r) <span class="fu">=</span> (<span class="dt">Zipper</span> (take n l) x (take n r))
λ<span class="fu">&gt;</span> take' <span class="dv">5</span> z
<span class="dt">Zipper</span> [<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">5</span>] <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]

<span class="co">-- duplicate</span>
λ<span class="fu">&gt;</span> take' <span class="dv">5</span> <span class="fu">$</span> fmap (take' <span class="dv">5</span>) <span class="fu">$</span> duplicate <span class="fu">$</span> z
<span class="dt">Zipper</span>
  [ <span class="dt">Zipper</span> [<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">5</span>,<span class="fu">-</span><span class="dv">6</span>] (<span class="fu">-</span><span class="dv">1</span>) [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]
  , <span class="dt">Zipper</span> [<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">5</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">7</span>] (<span class="fu">-</span><span class="dv">2</span>) [<span class="fu">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
  , <span class="dt">Zipper</span> [<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">5</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">7</span>,<span class="fu">-</span><span class="dv">8</span>] (<span class="fu">-</span><span class="dv">3</span>) [<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>]
  , <span class="dt">Zipper</span> [<span class="fu">-</span><span class="dv">5</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">7</span>,<span class="fu">-</span><span class="dv">8</span>,<span class="fu">-</span><span class="dv">9</span>] (<span class="fu">-</span><span class="dv">4</span>) [<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>]
  ,<span class="dt">Zipper</span> [<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">7</span>,<span class="fu">-</span><span class="dv">8</span>,<span class="fu">-</span><span class="dv">9</span>,<span class="fu">-</span><span class="dv">10</span>] (<span class="fu">-</span><span class="dv">5</span>) [<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">1</span>,<span class="dv">0</span>]
  ]
  (<span class="dt">Zipper</span> [<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">5</span>] <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>])
  [ <span class="dt">Zipper</span> [<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">4</span>] <span class="dv">1</span> [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]
  , <span class="dt">Zipper</span> [<span class="dv">1</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">3</span>] <span class="dv">2</span> [<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]
  , <span class="dt">Zipper</span> [<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">2</span>] <span class="dv">3</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>]
  , <span class="dt">Zipper</span> [<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>] <span class="dv">4</span> [<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>]
  , <span class="dt">Zipper</span> [<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>] <span class="dv">5</span> [<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]
  ]

<span class="co">-- extend . extract</span>
λ<span class="fu">&gt;</span> take' <span class="dv">5</span> <span class="fu">$</span> extend extract z
<span class="dt">Zipper</span> [<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">5</span>] <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>] <span class="co">-- this makes sense, also is a law!</span>

<span class="co">-- extend (without leveraging context)</span>
λ<span class="fu">&gt;</span> take' <span class="dv">5</span> <span class="fu">$</span> extend (\(<span class="dt">Zipper</span> _ x _) <span class="ot">-&gt;</span> <span class="dv">2</span> <span class="fu">*</span> x) z
<span class="dt">Zipper</span> [<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">8</span>,<span class="fu">-</span><span class="dv">10</span>] <span class="dv">0</span> [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]

<span class="co">-- extend (looking to the immediate left and right)</span>
λ<span class="fu">&gt;</span> take' <span class="dv">5</span> <span class="fu">$</span> extend (\(<span class="dt">Zipper</span> (l<span class="fu">:</span>_) x (r<span class="fu">:</span>_)) <span class="ot">-&gt;</span> l <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span> x <span class="fu">+</span> r) z
<span class="dt">Zipper</span> [<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">8</span>,<span class="fu">-</span><span class="dv">12</span>,<span class="fu">-</span><span class="dv">16</span>,<span class="fu">-</span><span class="dv">20</span>] <span class="dv">0</span> [<span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">12</span>,<span class="dv">16</span>,<span class="dv">20</span>]
λ<span class="fu">&gt;</span> take' <span class="dv">5</span> <span class="fu">$</span> extend (\(<span class="dt">Zipper</span> (l<span class="fu">:</span>_) x (r<span class="fu">:</span>_)) <span class="ot">-&gt;</span> concat <span class="fu">.</span> intersperse <span class="st">&quot;,&quot;</span> <span class="fu">.</span> map show <span class="fu">$</span> [l,x,r]) z
<span class="dt">Zipper</span>
  [<span class="st">&quot;-2,-1,0&quot;</span>,<span class="st">&quot;-3,-2,-1&quot;</span>,<span class="st">&quot;-4,-3,-2&quot;</span>,<span class="st">&quot;-5,-4,-3&quot;</span>,<span class="st">&quot;-6,-5,-4&quot;</span>]
  <span class="st">&quot;-1,0,1&quot;</span>
  [<span class="st">&quot;0,1,2&quot;</span>,<span class="st">&quot;1,2,3&quot;</span>,<span class="st">&quot;2,3,4&quot;</span>,<span class="st">&quot;3,4,5&quot;</span>,<span class="st">&quot;4,5,6&quot;</span>]</code></pre></div>
<p>Hopefully these examples show how comonads are a very fitting solution to computing cellular autamata. Again, refer to <a href="#further-reading">resources</a> if you are unsatisfied, as there’s plenty of content to read up on.</p>
<h3 id="applying-to-the-game-of-life">Applying to the Game of Life</h3>
<p>I want to change as little as possible from my current implementation - ideally just swap out the data structure and change very little in my frontend and test suite.</p>
<h2 id="performance">Performance</h2>
<h3 id="initial">Initial</h3>
<p>Here are some profiling details from the first implementation, which mapped across the board while performing lookups to retrieve the neighborhood values:</p>
<ul>
<li>Time: <strong>13.87s</strong></li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="bu">time</span> ./Spec +RTS -hc -p -K100M
<span class="ex">...</span>
<span class="ex">...</span> 13.87s user 0.02s system 100% cpu 13.875 total</code></pre></div>
<ul>
<li>Memory:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># getting a web friendly view of heap profiler</span>
$ <span class="ex">hp2ps</span> -e8in -c Spec.hp
$ <span class="ex">convert</span> Spec.ps initial-heap-profiling.png</code></pre></div>
<div class="figure">
<img src="../img/comonadic-gol/initial-heap.png" />

</div>
<p>Quite a bit of memory spent in the <code>step</code> function.</p>
<h3 id="comonads-to-the-rescue">Comonads to the rescue</h3>
<h2 id="further-reading">Further reading</h2>
<p>For more in-depth reading on category theory and comonads, here are my sources:</p>
<ul>
<li><a href="http://blog.ezyang.com/2012/10/duality-for-haskellers/">Duality for Haskellers</a> - EZ Yang</li>
<li><a href="http://blog.ezyang.com/2010/07/flipping-arrows-in-coburger-king/">Flipping arrows in coBurger King</a> - EZ Yang</li>
<li><a href="https://www.youtube.com/watch?v=F7F-BzOB670">Comonad presentation</a> - Kenny Foner</li>
<li><a href="https://github.com/kwf/ComonadSheet">ComonadSheet source code</a> - Kenny Foner</li>
<li><a href="https://www.slideshare.net/davidoverton/comonad">Another comonad presentation</a> - David Overton</li>
</ul>
</div>

<hr />

<p>You can see other articles <a href="../">here</a>.</p>

  </body>
</html>
